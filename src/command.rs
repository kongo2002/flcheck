use crate::pubdev::fetch_dep_versions;
use crate::pubspec::Dependency;
use crate::Config;
use crate::FlError;
use crate::FlError::ValidationError;
use crate::Pubspec;
use futures::future::try_join_all;
use std::collections::HashMap;
use std::collections::HashSet;

pub fn graph(pubspecs: Vec<Pubspec>) -> Result<(), FlError> {
    println!("//");
    println!("// automatically generated by flcheck <https://github.com/kongo2002/flcheck>");
    println!("//");
    println!("digraph dependencies {{");
    println!("  ranksep =\"2.0 equally\";");

    for pubspec in pubspecs {
        println!("  // {}", pubspec.name);
        println!("  {} []", pubspec.name);

        for dep in pubspec.dependencies {
            match dep {
                Dependency::Local { name, path: _ } => println!("  {} -> {};", pubspec.name, name),
                Dependency::Git {
                    name,
                    path: _,
                    git: _,
                } => println!("  {} -> {};", pubspec.name, name),
                _ => {}
            }
        }
    }

    println!("}}");

    Ok(())
}

pub async fn check(pubspecs: Vec<Pubspec>) -> Result<(), FlError> {
    let unique_packages = pubspecs
        .iter()
        .flat_map(|pkg| {
            pkg.dependencies.iter().flat_map(|dep| match dep {
                Dependency::Public { name, version: _ } => Some(name),
                _ => None,
            })
        })
        .collect::<HashSet<_>>();

    let versions = try_join_all(
        unique_packages
            .iter()
            .map(|package| fetch_dep_versions(package)),
    )
    .await?;

    let lookup = versions
        .into_iter()
        .map(|pubversion| (pubversion.name.clone(), pubversion))
        .collect::<HashMap<_, _>>();

    for pubspec in pubspecs {
        println!("{}", pubspec.name);

        for dep in pubspec.dependencies {
            match dep {
                Dependency::Public { name, version } => {
                    let pub_version = lookup.get(&name).map(|vsn| &vsn.latest);
                    println!(
                        "  {}: {} [{}]",
                        name,
                        version,
                        pub_version.map_or("<unknown>", String::as_str)
                    );
                }
                _ => {}
            }
        }
    }
    Ok(())
}

pub fn dump(pubspecs: Vec<Pubspec>) -> Result<(), FlError> {
    for pubspec in pubspecs {
        // TODO: implement proper Display
        println!("{:?}", pubspec)
    }
    Ok(())
}

pub fn validate(config: Config, pubspecs: Vec<Pubspec>) -> Result<(), FlError> {
    let mut num_errors = 0u32;
    for pubspec in pubspecs.iter() {
        for val in pubspec.validate(&config, &pubspecs) {
            num_errors += 1;
            eprintln!("{:?}", val)
        }
    }

    if num_errors > 0 {
        Err(ValidationError(num_errors))
    } else {
        Ok(())
    }
}
