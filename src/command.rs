use crate::Config;
use crate::FlError;
use crate::FlError::ValidationError;
use crate::Opts;
use crate::Pubspec;
use crate::cli::OutputFormat;
use crate::dependency::Dependency;
use crate::error::PackageValidation;
use crate::error::ValidationLevel;
use crate::pubdev::fetch_dep_versions;
use futures::future::try_join_all;
use serde::Serialize;
use std::collections::HashMap;
use std::collections::HashSet;

#[derive(Serialize)]
struct JsonValidationResult {
    pub errors: Vec<PackageValidation>,
    pub warnings: Vec<PackageValidation>,
}

#[derive(Serialize)]
struct JsonDumpResult {
    pub pubspecs: Vec<Pubspec>,
}

pub fn graph(pubspecs: Vec<Pubspec>) -> Result<(), FlError> {
    println!("//");
    println!("// automatically generated by flcheck <https://github.com/kongo2002/flcheck>");
    println!("//");
    println!("digraph dependencies {{");
    println!("  ranksep =\"2.0 equally\";");

    for pubspec in pubspecs {
        println!("  // {}", pubspec.name);
        println!("  {} []", pubspec.name);

        for dep in pubspec.dependencies {
            match dep.effective() {
                Dependency::Local { name, .. } => println!("  {} -> {};", pubspec.name, name),
                Dependency::Git { name, .. } => println!("  {} -> {};", pubspec.name, name),
                _ => {}
            }
        }
    }

    println!("}}");
    Ok(())
}

pub async fn check(pubspecs: Vec<Pubspec>) -> Result<(), FlError> {
    let unique_packages = pubspecs
        .iter()
        .flat_map(|pkg| {
            pkg.dependencies.iter().flat_map(|dep| match dep {
                Dependency::PubDev { name, .. } => Some(name),
                _ => None,
            })
        })
        .collect::<HashSet<_>>();

    let versions = try_join_all(
        unique_packages
            .iter()
            .map(|package| fetch_dep_versions(package)),
    )
    .await?;

    let lookup = versions
        .into_iter()
        .map(|pubversion| (pubversion.name.clone(), pubversion))
        .collect::<HashMap<_, _>>();

    for pubspec in pubspecs {
        println!("{}", pubspec.name);

        for dep in pubspec.dependencies {
            if let Dependency::PubDev { name, version, .. } = dep {
                let pub_version = lookup.get(&name).map(|vsn| &vsn.latest);
                println!(
                    "  {}: {} [{}]",
                    name,
                    version,
                    pub_version.map_or("<unknown>", String::as_str)
                );
            }
        }
    }
    Ok(())
}

pub fn dump(opts: Opts, pubspecs: Vec<Pubspec>) -> Result<(), FlError> {
    match opts.output {
        OutputFormat::Json => {
            let json_output = JsonDumpResult { pubspecs };

            serde_json::to_string(&json_output)
                .ok()
                .iter()
                .for_each(|json| println!("{}", json));
        }
        OutputFormat::Plain => {
            for pubspec in pubspecs {
                print_pubspec_plain(pubspec)
            }
        }
    }
    Ok(())
}

fn print_pubspec_plain(pubspec: Pubspec) {
    println!("{} [{}]:", pubspec.name, pubspec.path);

    if !pubspec.dependencies.is_empty() {
        println!("  dependencies:");
        for dep in pubspec.dependencies.iter() {
            print_dependency_plain(dep)
        }
    }

    if !pubspec.dev_dependencies.is_empty() {
        println!("  dev-dependencies:");
        for dep in pubspec.dev_dependencies.iter() {
            print_dependency_plain(dep)
        }
    }
}

fn print_dependency_plain(dep: &Dependency) {
    println!("    {} {}", dep.name(), dep.details());
    dep.overridden().iter().for_each(|override_dependency| {
        println!(
            "      override: {} {}",
            override_dependency.name(),
            override_dependency.details()
        );
    })
}

fn print_validation_plain(validation: &PackageValidation) {
    println!(
        "{}: {}: {} [{}]",
        validation.level, validation.package_name, validation.error, validation.code
    );

    validation.description.iter().for_each(|desc| {
        println!("\t{}", desc);
    })
}

pub fn validate(opts: Opts, config: Config, pubspecs: Vec<Pubspec>) -> Result<(), FlError> {
    let num_errors = match opts.output {
        OutputFormat::Plain => {
            let mut num_errors = 0u32;
            for pubspec in pubspecs.iter() {
                let validation_errors = pubspec.validate(&config, &pubspecs);
                let grouped = group_validations(validation_errors);

                for error in grouped.errors {
                    num_errors += 1;

                    print_validation_plain(&error)
                }

                for warning in grouped.warnings {
                    print_validation_plain(&warning)
                }
            }
            num_errors
        }
        OutputFormat::Json => {
            let validations = pubspecs
                .iter()
                .flat_map(|pubspec| pubspec.validate(&config, &pubspecs))
                .collect::<Vec<_>>();

            let grouped = group_validations(validations);

            serde_json::to_string(&grouped)
                .ok()
                .iter()
                .for_each(|json| println!("{}", json));

            grouped.errors.len() as u32
        }
    };

    if num_errors > 0 {
        Err(ValidationError(num_errors))
    } else {
        Ok(())
    }
}

fn group_validations(validations: Vec<PackageValidation>) -> JsonValidationResult {
    let mut warnings = Vec::new();
    let mut errors = Vec::new();

    for validation in validations {
        match validation.level {
            ValidationLevel::Error => errors.push(validation),
            ValidationLevel::Warning => warnings.push(validation),
            ValidationLevel::None => {}
        }
    }

    JsonValidationResult { warnings, errors }
}

pub fn example_config() {
    println!(
        r#"# Package types list rules for packages that describe
# what package is allowed to depend on each other.
#
# The typical recommended setup is a hierachy like the following:
# - main: the main app that is shipped and distributed to app stores and
#   assembles the functionalities of one or multiple (sub) apps
# - app: one or multiple (sub) apps that encapsulate functionalities of
#   usually one domain per app - must not depend on each other
# - shared: few shared libraries that can be used the glue together
#   multiple apps, e.g. for routing, navigation - must import packages
#   and other shared libraries only
# - package: general purpose libraries (e.g. utilities) that do not contain
#   domain specific logic, may be included from any package type/layer
package_types:

  main:
    # the dir_prefix is used to associate every dart package to one
    # of the package types listed here, is applied to the directory
    # name of the package
    dir_prefix: 'main'
    # list of package types all packages of this type may import from
    # (here: main is allowed to import all apps and everything that apps
    # are allowed to import themselves)
    includes:
      - app

  app:
    dir_prefix: 'app_'
    includes:
      - shared

  shared:
    dir_prefix: 'shared_'
    includes:
      - shared
      - package

  package:
    # you can also specify a list of directory prefixes
    dir_prefix:
      - 'pkg_'
      - 'util_'
    includes:
      - package

# List of patterns (regular expressions) that match package directories
# that should be excluded from all validations and checks.
# Here: exclude all auto-generated "example" packages from native dart
# packages.
blacklist:
  - '/example'

# You can configure what kind of validations are associated with what
# level of severity: `error` for errors, `warn` for warnings or
# `none` to be ignored.
# If not specified, every validation defaults to `error`
validations:
  validation:dev-dependency:git: error
  validation:dependency:unknown: error
  validation:dependency:unallowed: error
  validation:dependency:cyclic: error
  validation:public:dependency:non-git: error
"#
    );
}
